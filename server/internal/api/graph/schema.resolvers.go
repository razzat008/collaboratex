package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"gollaboratex/server/internal/api/graph/model"
	database "gollaboratex/server/internal/db"
	"log"

	"go.mongodb.org/mongo-driver/v2/bson"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	user_collection := db.Collection("User")
	new_user := model.User{}
	new_user.Email = input.Email
	new_user.UserName = input.UserName
	user_collection.InsertOne(ctx, &new_user)

	return &new_user, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.NewProject) (*model.Project, error) {
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	project_collection := db.Collection("Project")
	project := model.Project{}
	project.OwnedBy.ID = input.OwnedBy
	project.ProjectName = input.ProjectName
	project_collection.InsertOne(ctx, &project)
	return &project, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, projectID string) (bool, error) {
	// implement a function for delete proejct by projectID
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	project_collection := db.Collection("Project")
	filter := bson.M{"_id": projectID}
	result, err := project_collection.DeleteOne(ctx, filter)
	if err != nil {
		log.Fatal("Delete failed")
	}
	if result.DeletedCount == 0 {
		return false, nil
	}
	return true, nil
}

// AddCollaborator is the resolver for the addCollaborator field.
func (r *mutationResolver) AddCollaborator(ctx context.Context, projectID string, userID string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: AddCollaborator - addCollaborator"))
}

// RemoveCollaborator is the resolver for the removeCollaborator field.
func (r *mutationResolver) RemoveCollaborator(ctx context.Context, projectID string, userID string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: RemoveCollaborator - removeCollaborator"))
}

// CreateFile is the resolver for the createFile field.
func (r *mutationResolver) CreateFile(ctx context.Context, input model.NewFile) (*model.File, error) {
	panic(fmt.Errorf("not implemented: CreateFile - createFile"))
}

// UpdateFile is the resolver for the updateFile field.
func (r *mutationResolver) UpdateFile(ctx context.Context, fileID string, content string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: UpdateFile - updateFile"))
}

// RenameFile is the resolver for the renameFile field.
func (r *mutationResolver) RenameFile(ctx context.Context, fileID string, name string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: RenameFile - renameFile"))
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteFile - deleteFile"))
}

// CreateVersion is the resolver for the createVersion field.
func (r *mutationResolver) CreateVersion(ctx context.Context, projectID string, message *string) (*model.Version, error) {
	panic(fmt.Errorf("not implemented: CreateVersion - createVersion"))
}

// RestoreVersion is the resolver for the restoreVersion field.
func (r *mutationResolver) RestoreVersion(ctx context.Context, versionID string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: RestoreVersion - restoreVersion"))
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	cursor, err := db.Collection("Project").Find(ctx, bson.D{})
	if err != nil {
		log.Fatal("Find failed")
	}
	var projects []*model.Project
	defer cursor.Close(ctx)
	for cursor.Next(ctx) {
		var project model.Project
		if err := cursor.Decode(&project); err != nil {
			return nil, err
		}
		projects = append(projects, &project)
	}
	return projects, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	var project model.Project
	filter := bson.M{"_id": id}
	err = db.Collection("Project").FindOne(ctx, filter).Decode(&project)
	if err != nil {
		log.Fatal("FindOne failed")
	}
	return &project, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	db, err := database.GetDatabase()
	if err != nil {
		log.Fatal(fmt.Errorf("couldn't retrieve database"))
	}
	var user model.User
	filter := bson.M{"_id": id}
	err = db.Collection("User").FindOne(ctx, filter).Decode(&user)
	if err != nil {
		log.Fatal("FindOne failed")
	}
	return &user, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: File - file"))
}

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context, id string) (*model.Version, error) {
	panic(fmt.Errorf("not implemented: Version - version"))
}

// FileUpdated is the resolver for the fileUpdated field.
func (r *subscriptionResolver) FileUpdated(ctx context.Context, projectID string) (<-chan *model.File, error) {
	panic(fmt.Errorf("not implemented: FileUpdated - fileUpdated"))
}

// ProjectUpdated is the resolver for the projectUpdated field.
func (r *subscriptionResolver) ProjectUpdated(ctx context.Context, projectID string) (<-chan *model.Project, error) {
	panic(fmt.Errorf("not implemented: ProjectUpdated - projectUpdated"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
