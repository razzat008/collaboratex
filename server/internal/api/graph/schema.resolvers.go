package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"errors"
	"fmt"
	"gollaboratex/server/internal/api/graph/model"
	"gollaboratex/server/internal/middleware"
	"path/filepath"
	"time"

	"github.com/minio/minio-go/v7"
	"go.mongodb.org/mongo-driver/v2/bson"
)

// WorkingFile is the resolver for the workingFile field.
func (r *fileResolver) WorkingFile(ctx context.Context, obj *model.File) (*model.WorkingFile, error) {
	fileOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, err
	}

	var workingFile WorkingFileDoc
	err = r.DB.Collection("working_files").FindOne(ctx, bson.M{"fileId": fileOID}).Decode(&workingFile)
	if err != nil {
		return nil, err
	}

	return &model.WorkingFile{
		ID:        workingFile.ID.Hex(),
		FileID:    workingFile.FileID.Hex(),
		ProjectID: workingFile.ProjectID.Hex(),
		Content:   workingFile.Content,
		UpdatedAt: workingFile.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.NewProjectInput) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	now := time.Now()

	// Create root file first
	rootFile := FileDoc{
		Name:      "main.tex",
		Type:      "TEX",
		CreatedAt: now,
		UpdatedAt: now,
	}

	rootFileResult, err := r.DB.Collection("files").InsertOne(ctx, rootFile)
	if err != nil {
		return nil, err
	}
	rootFileID := rootFileResult.InsertedID.(bson.ObjectID)

	// Create project
	project := ProjectDoc{
		ProjectName:     input.ProjectName,
		OwnerID:         user.ID,
		CollaboratorIDs: []bson.ObjectID{},
		RootFileID:      rootFileID,
		LastEditedAt:    now,
		CreatedAt:       now,
	}

	projectResult, err := r.DB.Collection("projects").InsertOne(ctx, project)
	if err != nil {
		return nil, err
	}
	project.ID = projectResult.InsertedID.(bson.ObjectID)

	// Update root file with projectId
	r.DB.Collection("files").UpdateOne(ctx,
		bson.M{"_id": rootFileID},
		bson.M{"$set": bson.M{"projectId": project.ID}},
	)

	// Create root working file
	workingFile := WorkingFileDoc{
		FileID:    rootFileID,
		ProjectID: project.ID,
		Content:   "",
		UpdatedAt: now,
	}

	_, err = r.DB.Collection("working_files").InsertOne(ctx, workingFile)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	collabIDs := make([]string, len(project.CollaboratorIDs))
	for i, id := range project.CollaboratorIDs {
		collabIDs[i] = id.Hex()
	}

	return &model.Project{
		ID:              project.ID.Hex(),
		ProjectName:     project.ProjectName,
		CreatedAt:       project.CreatedAt.Format(time.RFC3339),
		LastEditedAt:    project.LastEditedAt.Format(time.RFC3339),
		OwnerID:         project.OwnerID.Hex(),
		CollaboratorIds: collabIDs,
		RootFileID:      project.RootFileID.Hex(),
	}, nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, projectID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, err
	}

	projectOID, err := toObjectID(projectID)
	if err != nil {
		return false, err
	}

	isOwner, err := r.isProjectOwner(ctx, projectOID, user.ID)
	if err != nil || !isOwner {
		return false, errors.New("only owner can delete project")
	}

	// Get all files
	cursor, err := r.DB.Collection("files").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return false, err
	}
	defer cursor.Close(ctx)

	var files []FileDoc
	cursor.All(ctx, &files)

	// Delete all working files
	for _, file := range files {
		r.DB.Collection("working_files").DeleteOne(ctx, bson.M{"fileId": file.ID})
	}

	// Delete all files
	r.DB.Collection("files").DeleteMany(ctx, bson.M{"projectId": projectOID})

	// Delete project (versions remain)
	_, err = r.DB.Collection("projects").DeleteOne(ctx, bson.M{"_id": projectOID})
	if err != nil {
		return false, err
	}

	return true, nil
}

// AddCollaborator is the resolver for the addCollaborator field.
func (r *mutationResolver) AddCollaborator(ctx context.Context, projectID string, userID string) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(projectID)
	if err != nil {
		return nil, err
	}

	isOwner, err := r.isProjectOwner(ctx, projectOID, user.ID)
	if err != nil || !isOwner {
		return nil, errors.New("only owner can add collaborators")
	}

	// Convert userID string to ObjectID
	collaboratorOID, err := toObjectID(userID)
	if err != nil {
		return nil, errors.New("invalid user ID format")
	}

	// Check if user exists
	var collaborator UserDoc
	err = r.DB.Collection("User").FindOne(ctx, bson.M{"_id": collaboratorOID}).Decode(&collaborator)
	if err != nil {
		return nil, errors.New("collaborator not found")
	}

	// Add collaborator to project
	_, err = r.DB.Collection("projects").UpdateOne(ctx,
		bson.M{"_id": projectOID},
		bson.M{"$addToSet": bson.M{"collaboratorIds": collaboratorOID}},
	)
	if err != nil {
		return nil, err
	}

	// Use the query resolver through the parent Resolver
	qr := &queryResolver{r.Resolver}
	return qr.Project(ctx, projectID)
}

// RemoveCollaborator is the resolver for the removeCollaborator field.
func (r *mutationResolver) RemoveCollaborator(ctx context.Context, projectID string, userID string) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(projectID)
	if err != nil {
		return nil, err
	}

	isOwner, err := r.isProjectOwner(ctx, projectOID, user.ID)
	if err != nil || !isOwner {
		return nil, errors.New("only owner can remove collaborators")
	}

	collaboratorOID, err := toObjectID(userID)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.Collection("projects").UpdateOne(ctx,
		bson.M{"_id": projectOID},
		bson.M{"$pull": bson.M{"collaboratorIds": collaboratorOID}},
	)
	if err != nil {
		return nil, err
	}

	// Use the query resolver through the parent Resolver
	qr := &queryResolver{r.Resolver}
	return qr.Project(ctx, projectID)
}

// CreateFile is the resolver for the createFile field.
func (r *mutationResolver) CreateFile(ctx context.Context, input model.NewFileInput) (*model.File, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(input.ProjectID)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, projectOID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	now := time.Now()
	file := FileDoc{
		ProjectID: projectOID,
		Name:      input.Name,
		Type:      fileTypeToString(input.Type),
		CreatedAt: now,
		UpdatedAt: now,
	}

	fileResult, err := r.DB.Collection("files").InsertOne(ctx, file)
	if err != nil {
		return nil, err
	}
	file.ID = fileResult.InsertedID.(bson.ObjectID)

	workingFile := WorkingFileDoc{
		FileID:    file.ID,
		ProjectID: projectOID,
		Content:   "",
		UpdatedAt: now,
	}

	_, err = r.DB.Collection("working_files").InsertOne(ctx, workingFile)
	if err != nil {
		return nil, err
	}

	// Update project lastEditedAt
	r.DB.Collection("projects").UpdateOne(ctx,
		bson.M{"_id": projectOID},
		bson.M{"$set": bson.M{"lastEditedAt": now}},
	)

	return &model.File{
		ID:        file.ID.Hex(),
		ProjectID: file.ProjectID.Hex(),
		Name:      file.Name,
		Type:      stringToFileType(file.Type),
		CreatedAt: file.CreatedAt.Format(time.RFC3339),
		UpdatedAt: file.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// RenameFile is the resolver for the renameFile field.
func (r *mutationResolver) RenameFile(ctx context.Context, fileID string, name string) (*model.File, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	fileOID, err := toObjectID(fileID)
	if err != nil {
		return nil, err
	}

	var file FileDoc
	err = r.DB.Collection("files").FindOne(ctx, bson.M{"_id": fileOID}).Decode(&file)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, file.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	now := time.Now()
	_, err = r.DB.Collection("files").UpdateOne(ctx,
		bson.M{"_id": fileOID},
		bson.M{"$set": bson.M{"name": name, "updatedAt": now}},
	)
	if err != nil {
		return nil, err
	}

	// Use the query resolver through the parent Resolver
	qr := &queryResolver{r.Resolver}
	return qr.File(ctx, fileID)
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, err
	}

	fileOID, err := toObjectID(fileID)
	if err != nil {
		return false, err
	}

	var file FileDoc
	err = r.DB.Collection("files").FindOne(ctx, bson.M{"_id": fileOID}).Decode(&file)
	if err != nil {
		return false, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, file.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return false, errors.New("access denied")
	}

	// Delete file and working file (keep version files)
	r.DB.Collection("files").DeleteOne(ctx, bson.M{"_id": fileOID})
	r.DB.Collection("working_files").DeleteOne(ctx, bson.M{"fileId": fileOID})

	return true, nil
}

// UpdateWorkingFile is the resolver for the updateWorkingFile field.
func (r *mutationResolver) UpdateWorkingFile(ctx context.Context, input model.UpdateWorkingFileInput) (*model.WorkingFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	fileOID, err := toObjectID(input.FileID)
	if err != nil {
		return nil, err
	}

	// Get file to check project access
	var file FileDoc
	err = r.DB.Collection("files").FindOne(ctx, bson.M{"_id": fileOID}).Decode(&file)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, file.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	now := time.Now()
	update := bson.M{
		"$set": bson.M{
			"content":   input.Content,
			"updatedAt": now,
		},
	}

	var workingFile WorkingFileDoc
	err = r.DB.Collection("working_files").FindOneAndUpdate(
		ctx,
		bson.M{"fileId": fileOID},
		update,
		// options.FindOneAndUpdate().SetReturnDocument(options.After),
	).Decode(&workingFile)
	if err != nil {
		return nil, err
	}

	// Update project lastEditedAt
	r.DB.Collection("projects").UpdateOne(ctx,
		bson.M{"_id": file.ProjectID},
		bson.M{"$set": bson.M{"lastEditedAt": now}},
	)

	// Use the query resolver through the parent Resolver
	qr := &queryResolver{r.Resolver}
	return qr.WorkingFile(ctx, input.FileID)
}

// CreateVersion is the resolver for the createVersion field.
func (r *mutationResolver) CreateVersion(ctx context.Context, input model.CreateVersionInput) (*model.Version, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(input.ProjectID)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, projectOID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	// Fetch all files for this project
	cursor, err := r.DB.Collection("files").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var files []FileDoc
	if err = cursor.All(ctx, &files); err != nil {
		return nil, err
	}

	// Create version
	now := time.Now()
	version := VersionDoc{
		ProjectID: projectOID,
		Message:   input.Message,
		CreatedAt: now,
	}

	versionResult, err := r.DB.Collection("versions").InsertOne(ctx, version)
	if err != nil {
		return nil, err
	}
	version.ID = versionResult.InsertedID.(bson.ObjectID)

	// Create version files
	for _, file := range files {
		var workingFile WorkingFileDoc
		err = r.DB.Collection("working_files").FindOne(ctx, bson.M{"fileId": file.ID}).Decode(&workingFile)
		if err != nil {
			continue
		}

		versionFile := VersionFileDoc{
			VersionID: version.ID,
			FileID:    file.ID,
			Name:      file.Name,
			Type:      file.Type,
			Content:   workingFile.Content,
		}

		r.DB.Collection("version_files").InsertOne(ctx, versionFile)
	}

	return &model.Version{
		ID:        version.ID.Hex(),
		ProjectID: version.ProjectID.Hex(),
		CreatedAt: version.CreatedAt.Format(time.RFC3339),
		Message:   version.Message,
	}, nil
}

// RestoreVersion is the resolver for the restoreVersion field.
func (r *mutationResolver) RestoreVersion(ctx context.Context, versionID string) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	versionOID, err := toObjectID(versionID)
	if err != nil {
		return nil, err
	}

	// Get version
	var version VersionDoc
	err = r.DB.Collection("versions").FindOne(ctx, bson.M{"_id": versionOID}).Decode(&version)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, version.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	// Get version files
	cursor, err := r.DB.Collection("version_files").Find(ctx, bson.M{"versionId": versionOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var versionFiles []VersionFileDoc
	if err = cursor.All(ctx, &versionFiles); err != nil {
		return nil, err
	}

	now := time.Now()

	// Restore each file
	for _, vf := range versionFiles {
		update := bson.M{
			"$set": bson.M{
				"content":   vf.Content,
				"updatedAt": now,
			},
		}

		r.DB.Collection("working_files").UpdateOne(ctx,
			bson.M{"fileId": vf.FileID},
			update,
		)
	}

	// Update project lastEditedAt
	r.DB.Collection("projects").UpdateOne(ctx,
		bson.M{"_id": version.ProjectID},
		bson.M{"$set": bson.M{"lastEditedAt": now}},
	)

	// Use the query resolver through the parent Resolver
	qr := &queryResolver{r.Resolver}
	return qr.Project(ctx, version.ProjectID.Hex())
}

// CreateAsset is the resolver for the createAsset field.
func (r *mutationResolver) CreateAsset(ctx context.Context, input model.CreateAssetInput) (*model.Asset, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(input.ProjectID)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, projectOID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	now := time.Now()
	asset := AssetDoc{
		ProjectID: projectOID,
		Path:      input.Path,
		MimeType:  input.MimeType,
		Size:      int(input.Size),
		CreatedAt: now,
	}

	result, err := r.DB.Collection("assets").InsertOne(ctx, asset)
	if err != nil {
		return nil, err
	}
	asset.ID = result.InsertedID.(bson.ObjectID)

	return &model.Asset{
		ID:        asset.ID.Hex(),
		ProjectID: asset.ProjectID.Hex(),
		Path:      asset.Path,
		MimeType:  asset.MimeType,
		Size:      int32(asset.Size),
		CreatedAt: asset.CreatedAt.Format(time.RFC3339),
	}, nil
}


// Files is the resolver for the files field.
func (r *projectResolver) Files(ctx context.Context, obj *model.Project) ([]*model.File, error) {
	projectOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, err
	}

	cursor, err := r.DB.Collection("files").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var fileDocs []FileDoc
	if err = cursor.All(ctx, &fileDocs); err != nil {
		return nil, err
	}

	files := make([]*model.File, len(fileDocs))
	for i, f := range fileDocs {
		files[i] = &model.File{
			ID:        f.ID.Hex(),
			ProjectID: f.ProjectID.Hex(),
			Name:      f.Name,
			Type:      stringToFileType(f.Type),
			CreatedAt: f.CreatedAt.Format(time.RFC3339),
			UpdatedAt: f.UpdatedAt.Format(time.RFC3339),
		}
	}

	return files, nil
}

// Assets is the resolver for the assets field.
func (r *projectResolver) Assets(ctx context.Context, obj *model.Project) ([]*model.Asset, error) {
	projectOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, err
	}

	cursor, err := r.DB.Collection("assets").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var assetDocs []AssetDoc
	if err = cursor.All(ctx, &assetDocs); err != nil {
		return nil, err
	}

	assets := make([]*model.Asset, len(assetDocs))
	for i, a := range assetDocs {
		assets[i] = &model.Asset{
			ID:        a.ID.Hex(),
			ProjectID: a.ProjectID.Hex(),
			Path:      a.Path,
			MimeType:  a.MimeType,
			Size:      int32(a.Size),
			CreatedAt: a.CreatedAt.Format(time.RFC3339),
		}
	}

	return assets, nil
}

// Versions is the resolver for the versions field.
func (r *projectResolver) Versions(ctx context.Context, obj *model.Project) ([]*model.Version, error) {
	projectOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, err
	}

	cursor, err := r.DB.Collection("versions").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var versionDocs []VersionDoc
	if err = cursor.All(ctx, &versionDocs); err != nil {
		return nil, err
	}

	versions := make([]*model.Version, len(versionDocs))
	for i, v := range versionDocs {
		versions[i] = &model.Version{
			ID:        v.ID.Hex(),
			ProjectID: v.ProjectID.Hex(),
			CreatedAt: v.CreatedAt.Format(time.RFC3339),
			Message:   v.Message,
		}
	}

	return versions, nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context) ([]*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	filter := bson.M{
		"$or": []bson.M{
			{"ownerId": user.ID},
			{"collaboratorIds": user.ID},
		},
	}

	cursor, err := r.DB.Collection("projects").Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var projectDocs []ProjectDoc
	if err = cursor.All(ctx, &projectDocs); err != nil {
		return nil, err
	}

	projects := make([]*model.Project, len(projectDocs))
	for i, p := range projectDocs {
		collabIDs := make([]string, len(p.CollaboratorIDs))
		for j, id := range p.CollaboratorIDs {
			collabIDs[j] = id.Hex()
		}

		projects[i] = &model.Project{
			ID:              p.ID.Hex(),
			ProjectName:     p.ProjectName,
			CreatedAt:       p.CreatedAt.Format(time.RFC3339),
			LastEditedAt:    p.LastEditedAt.Format(time.RFC3339),
			OwnerID:         p.OwnerID.Hex(),
			CollaboratorIds: collabIDs,
			RootFileID:      p.RootFileID.Hex(),
		}
	}

	return projects, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	projectOID, err := toObjectID(id)
	if err != nil {
		return nil, err
	}

	var project ProjectDoc
	err = r.DB.Collection("projects").FindOne(ctx, bson.M{"_id": projectOID}).Decode(&project)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, projectOID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	collabIDs := make([]string, len(project.CollaboratorIDs))
	for i, id := range project.CollaboratorIDs {
		collabIDs[i] = id.Hex()
	}

	return &model.Project{
		ID:              project.ID.Hex(),
		ProjectName:     project.ProjectName,
		CreatedAt:       project.CreatedAt.Format(time.RFC3339),
		LastEditedAt:    project.LastEditedAt.Format(time.RFC3339),
		OwnerID:         project.OwnerID.Hex(),
		CollaboratorIds: collabIDs,
		RootFileID:      project.RootFileID.Hex(),
	}, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	fileOID, err := toObjectID(id)
	if err != nil {
		return nil, err
	}

	var file FileDoc
	err = r.DB.Collection("files").FindOne(ctx, bson.M{"_id": fileOID}).Decode(&file)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, file.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	return &model.File{
		ID:        file.ID.Hex(),
		ProjectID: file.ProjectID.Hex(),
		Name:      file.Name,
		Type:      stringToFileType(file.Type),
		CreatedAt: file.CreatedAt.Format(time.RFC3339),
		UpdatedAt: file.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// WorkingFile is the resolver for the workingFile field.
func (r *queryResolver) WorkingFile(ctx context.Context, fileID string) (*model.WorkingFile, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	fileOID, err := toObjectID(fileID)
	if err != nil {
		return nil, err
	}

	// Get file to check project access
	var file FileDoc
	err = r.DB.Collection("files").FindOne(ctx, bson.M{"_id": fileOID}).Decode(&file)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, file.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	var workingFile WorkingFileDoc
	err = r.DB.Collection("working_files").FindOne(ctx, bson.M{"fileId": fileOID}).Decode(&workingFile)
	if err != nil {
		return nil, err
	}

	return &model.WorkingFile{
		ID:        workingFile.ID.Hex(),
		FileID:    workingFile.FileID.Hex(),
		ProjectID: workingFile.ProjectID.Hex(),
		Content:   workingFile.Content,
		UpdatedAt: workingFile.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// Version is the resolver for the version field.
func (r *queryResolver) Version(ctx context.Context, id string) (*model.Version, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	versionOID, err := toObjectID(id)
	if err != nil {
		return nil, err
	}

	var version VersionDoc
	err = r.DB.Collection("versions").FindOne(ctx, bson.M{"_id": versionOID}).Decode(&version)
	if err != nil {
		return nil, err
	}

	hasAccess, err := r.hasProjectAccess(ctx, version.ProjectID, user.ID)
	if err != nil || !hasAccess {
		return nil, errors.New("access denied")
	}

	return &model.Version{
		ID:        version.ID.Hex(),
		ProjectID: version.ProjectID.Hex(),
		CreatedAt: version.CreatedAt.Format(time.RFC3339),
		Message:   version.Message,
	}, nil
}


// WorkingFileUpdated is the resolver for the workingFileUpdated field.
func (r *subscriptionResolver) WorkingFileUpdated(ctx context.Context, projectID string) (<-chan *model.WorkingFile, error) {
	// TODO: Implement using channels and MongoDB change streams or pub/sub
	// This is a placeholder - real implementation would use:
	// - MongoDB change streams to watch working_files collection
	// - Redis pub/sub for distributed systems
	// - In-memory channels for single-instance setups

	ch := make(chan *model.WorkingFile)

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
}

// ProjectUpdated is the resolver for the projectUpdated field.
func (r *subscriptionResolver) ProjectUpdated(ctx context.Context, projectID string) (<-chan *model.Project, error) {
	// TODO: Implement using channels and MongoDB change streams or pub/sub

	ch := make(chan *model.Project)

	go func() {
		<-ctx.Done()
		close(ch)
	}()

	return ch, nil
}


// Files is the resolver for the files field.
func (r *versionResolver) Files(ctx context.Context, obj *model.Version) ([]*model.VersionFile, error) {
	versionOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, err
	}

	cursor, err := r.DB.Collection("version_files").Find(ctx, bson.M{"versionId": versionOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var versionFileDocs []VersionFileDoc
	if err = cursor.All(ctx, &versionFileDocs); err != nil {
		return nil, err
	}

	files := make([]*model.VersionFile, len(versionFileDocs))
	for i, vf := range versionFileDocs {
		files[i] = &model.VersionFile{
			ID:        vf.ID.Hex(),
			VersionID: vf.VersionID.Hex(),
			FileID:    vf.FileID.Hex(),
			Name:      vf.Name,
			Type:      stringToFileType(vf.Type),
			Content:   vf.Content,
		}
	}

	return files, nil
}

// Templates
// ============================================================================
// QUERY RESOLVERS
// ============================================================================

// Templates is the resolver for the templates field.
func (r *queryResolver) Templates(ctx context.Context) ([]*model.Template, error) {
	cursor, err := r.DB.Collection("templates").Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var templateDocs []TemplateDoc
	if err = cursor.All(ctx, &templateDocs); err != nil {
		return nil, err
	}

	templates := make([]*model.Template, len(templateDocs))
	for i, t := range templateDocs {
		templates[i] = r.TemplateDocToModel(ctx, &t)
	}

	return templates, nil
}

// Template is the resolver for the template field.
func (r *queryResolver) Template(ctx context.Context, id string) (*model.Template, error) {
	templateOID, err := toObjectID(id)
	if err != nil {
		return nil, fmt.Errorf("invalid template ID: %w", err)
	}

	var template TemplateDoc
	err = r.DB.Collection("templates").FindOne(ctx, bson.M{"_id": templateOID}).Decode(&template)
	if err != nil {
		return nil, fmt.Errorf("template not found: %w", err)
	}

	return r.TemplateDocToModel(ctx, &template), nil
}

// PublicTemplates is the resolver for the publicTemplates field.
func (r *queryResolver) PublicTemplates(ctx context.Context) ([]*model.Template, error) {
	cursor, err := r.DB.Collection("templates").Find(ctx, bson.M{"isPublic": true})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var templateDocs []TemplateDoc
	if err = cursor.All(ctx, &templateDocs); err != nil {
		return nil, err
	}

	templates := make([]*model.Template, len(templateDocs))
	for i, t := range templateDocs {
		templates[i] = r.TemplateDocToModel(ctx, &t)
	}

	return templates, nil
}

// MyTemplates is the resolver for the myTemplates field.
func (r *queryResolver) MyTemplates(ctx context.Context) ([]*model.Template, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user not authenticated: %w", err)
	}

	cursor, err := r.DB.Collection("templates").Find(ctx, bson.M{"authorId": user.ID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var templateDocs []TemplateDoc
	if err = cursor.All(ctx, &templateDocs); err != nil {
		return nil, err
	}

	templates := make([]*model.Template, len(templateDocs))
	for i, t := range templateDocs {
		templates[i] = r.TemplateDocToModel(ctx, &t)
	}

	return templates, nil
}

// ============================================================================
// MUTATION RESOLVERS
// ============================================================================

// CreateTemplate is the resolver for the createTemplate field.
// This mutation converts an existing project to a template.
func (r *mutationResolver) CreateTemplate(ctx context.Context, projectID string, input model.CreateTemplateInput) (*model.Template, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user not authenticated: %w", err)
	}

	projectOID, err := toObjectID(projectID)
	if err != nil {
		return nil, fmt.Errorf("invalid project ID: %w", err)
	}

	// Verify project ownership
	isOwner, err := r.isProjectOwner(ctx, projectOID, user.ID)
	if err != nil || !isOwner {
		return nil, fmt.Errorf("only project owner can create template: %w", err)
	}

	now := time.Now()

	// Create template document
	template := TemplateDoc{
		Name:         input.Name,
		Description:  input.Description,
		AuthorID:     user.ID,
		IsPublic:     input.IsPublic,
		Tags:         input.Tags,
		PreviewImage: input.PreviewImage,
		CreatedAt:    now,
	}

	result, err := r.DB.Collection("templates").InsertOne(ctx, template)
	if err != nil {
		return nil, fmt.Errorf("failed to create template: %w", err)
	}
	template.ID = result.InsertedID.(bson.ObjectID)

	// Copy all files from project to template
	cursor, err := r.DB.Collection("files").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch project files: %w", err)
	}
	defer cursor.Close(ctx)

	var files []FileDoc
	if err = cursor.All(ctx, &files); err != nil {
		return nil, fmt.Errorf("failed to decode files: %w", err)
	}

	// For each file, get its content and create template file
	for _, file := range files {
		var workingFile WorkingFileDoc
		err := r.DB.Collection("working_files").FindOne(ctx, bson.M{"fileId": file.ID}).Decode(&workingFile)
		if err != nil {
			continue // Skip if no working file
		}

		templateFile := TemplateFileDoc{
			TemplateID: template.ID,
			Name:       file.Name,
			Type:       file.Type,
			Content:    workingFile.Content,
		}

		_, err = r.DB.Collection("template_files").InsertOne(ctx, templateFile)
		if err != nil {
			// Log but continue - don't fail the entire operation
			fmt.Printf("Warning: failed to create template file %s: %v\n", file.Name, err)
		}
	}

	// Copy all assets from project to template
	assetCursor, err := r.DB.Collection("assets").Find(ctx, bson.M{"projectId": projectOID})
	if err != nil {
		// Continue even if assets fetch fails
		fmt.Printf("Warning: failed to fetch project assets: %v\n", err)
	} else {
		defer assetCursor.Close(ctx)

		var assets []AssetDoc
		if assetCursor.All(ctx, &assets) == nil {
			for _, asset := range assets {
				templateAsset := TemplateAssetDoc{
					TemplateID: template.ID,
					Path:       asset.Path,
					MimeType:   asset.MimeType,
					Size:       asset.Size,
					CreatedAt:  asset.CreatedAt,
				}
				_, err = r.DB.Collection("template_assets").InsertOne(ctx, templateAsset)
				if err != nil {
					// Log but continue
					fmt.Printf("Warning: failed to create template asset %s: %v\n", asset.Path, err)
				}
			}
		}
	}

	return r.TemplateDocToModel(ctx, &template), nil
}

// UseTemplate is the resolver for the useTemplate field.
// This mutation creates a new project by copying template files and assets.
func (r *mutationResolver) UseTemplate(ctx context.Context, templateID string, projectName string) (*model.Project, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("user not authenticated: %w", err)
	}

	templateOID, err := toObjectID(templateID)
	if err != nil {
		return nil, fmt.Errorf("invalid template ID: %w", err)
	}

	// Verify template exists and is accessible
	var template TemplateDoc
	err = r.DB.Collection("templates").FindOne(ctx, bson.M{"_id": templateOID}).Decode(&template)
	if err != nil {
		return nil, fmt.Errorf("template not found: %w", err)
	}

	// Check if user has access (public or owner)
	if !template.IsPublic && template.AuthorID != user.ID {
		return nil, fmt.Errorf("template not accessible: private template")
	}

	now := time.Now()

	// Create root file
	rootFile := FileDoc{
		Name:      "main.tex",
		Type:      "TEX",
		CreatedAt: now,
		UpdatedAt: now,
	}

	rootFileResult, err := r.DB.Collection("files").InsertOne(ctx, rootFile)
	if err != nil {
		return nil, fmt.Errorf("failed to create root file: %w", err)
	}
	rootFileID := rootFileResult.InsertedID.(bson.ObjectID)

	// Create new project
	project := ProjectDoc{
		ProjectName:     projectName,
		OwnerID:         user.ID,
		CollaboratorIDs: []bson.ObjectID{},
		RootFileID:      rootFileID,
		LastEditedAt:    now,
		CreatedAt:       now,
	}

	projectResult, err := r.DB.Collection("projects").InsertOne(ctx, project)
	if err != nil {
		return nil, fmt.Errorf("failed to create project: %w", err)
	}
	project.ID = projectResult.InsertedID.(bson.ObjectID)

	// Update root file with projectId
	_, err = r.DB.Collection("files").UpdateOne(ctx,
		bson.M{"_id": rootFileID},
		bson.M{"$set": bson.M{"projectId": project.ID}},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update root file: %w", err)
	}

	// Create root working file
	workingFile := WorkingFileDoc{
		FileID:    rootFileID,
		ProjectID: project.ID,
		Content:   "",
		UpdatedAt: now,
	}
	_, err = r.DB.Collection("working_files").InsertOne(ctx, workingFile)
	if err != nil {
		return nil, fmt.Errorf("failed to create working file: %w", err)
	}

	// Copy all template files to project
	cursor, err := r.DB.Collection("template_files").Find(ctx, bson.M{"templateId": templateOID})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch template files: %w", err)
	}
	defer cursor.Close(ctx)

	var templateFiles []TemplateFileDoc
	if err = cursor.All(ctx, &templateFiles); err != nil {
		return nil, fmt.Errorf("failed to decode template files: %w", err)
	}

	for _, tf := range templateFiles {
		newFile := FileDoc{
			ProjectID: project.ID,
			Name:      tf.Name,
			Type:      tf.Type,
			CreatedAt: now,
			UpdatedAt: now,
		}

		fileResult, err := r.DB.Collection("files").InsertOne(ctx, newFile)
		if err != nil {
			// Log but continue
			fmt.Printf("Warning: failed to create file %s: %v\n", tf.Name, err)
			continue
		}
		newFileID := fileResult.InsertedID.(bson.ObjectID)

		// Create working file with template content
		newWorkingFile := WorkingFileDoc{
			FileID:    newFileID,
			ProjectID: project.ID,
			Content:   tf.Content,
			UpdatedAt: now,
		}
		_, err = r.DB.Collection("working_files").InsertOne(ctx, newWorkingFile)
		if err != nil {
			// Log but continue
			fmt.Printf("Warning: failed to create working file %s: %v\n", tf.Name, err)
		}
	}

	// Copy all template assets to project
assetCursor, err := r.DB.Collection("template_assets").Find(ctx, bson.M{"templateId": templateOID})
if err != nil {
    fmt.Printf("Warning: failed to fetch template assets: %v\n", err)
} else {
    defer assetCursor.Close(ctx)

    var templateAssets []TemplateAssetDoc
    if err := assetCursor.All(ctx, &templateAssets); err == nil {
        for _, ta := range templateAssets {

            filename := filepath.Base(ta.Path)

            newPath := fmt.Sprintf(
                "project/%s/assets/%s",
                project.ID.Hex(),
                filename,
            )

            // 1️⃣ copy MinIO object
            err := r.copyMinioObject(ctx, ta.Path, newPath)
            if err != nil {
                fmt.Printf("Warning: failed to copy asset %s: %v\n", ta.Path, err)
                continue
            }

            // 2️⃣ insert new project asset record
            newAsset := AssetDoc{
                ProjectID: project.ID,
                Path:      newPath,
                MimeType:  ta.MimeType,
                Size:      ta.Size,
                CreatedAt: now,
            }

            _, err = r.DB.Collection("assets").InsertOne(ctx, newAsset)
            if err != nil {
                fmt.Printf("Warning: failed to create asset record %s: %v\n", newPath, err)
            }
        }
    }
}

	// Convert to GraphQL model
	collabIDs := make([]string, len(project.CollaboratorIDs))
	for i, id := range project.CollaboratorIDs {
		collabIDs[i] = id.Hex()
	}

	return &model.Project{
		ID:              project.ID.Hex(),
		ProjectName:     project.ProjectName,
		CreatedAt:       project.CreatedAt.Format(time.RFC3339),
		LastEditedAt:    project.LastEditedAt.Format(time.RFC3339),
		OwnerID:         project.OwnerID.Hex(),
		CollaboratorIds: collabIDs,
		RootFileID:      project.RootFileID.Hex(),
	}, nil
}

func (r *mutationResolver) copyMinioObject(
    ctx context.Context,
    srcPath string,
    dstPath string,
) error {
    src := minio.CopySrcOptions{
        Bucket: r.Bucket,
        Object: srcPath,
    }

    dst := minio.CopyDestOptions{
        Bucket: r.Bucket,
        Object: dstPath,
    }

    _, err := r.Minio.CopyObject(ctx, dst, src)
    return err
}

// DeleteTemplate is the resolver for the deleteTemplate field.
func (r *mutationResolver) DeleteTemplate(ctx context.Context, templateID string) (bool, error) {
	user, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("user not authenticated: %w", err)
	}

	templateOID, err := toObjectID(templateID)
	if err != nil {
		return false, fmt.Errorf("invalid template ID: %w", err)
	}

	// Verify template ownership
	var template TemplateDoc
	err = r.DB.Collection("templates").FindOne(ctx, bson.M{"_id": templateOID}).Decode(&template)
	if err != nil {
		return false, fmt.Errorf("template not found: %w", err)
	}

	if template.AuthorID != user.ID {
		return false, fmt.Errorf("only author can delete template")
	}

	// Delete template files
	_, err = r.DB.Collection("template_files").DeleteMany(ctx, bson.M{"templateId": templateOID})
	if err != nil {
		return false, fmt.Errorf("failed to delete template files: %w", err)
	}

	// Delete template assets
	_, err = r.DB.Collection("template_assets").DeleteMany(ctx, bson.M{"templateId": templateOID})
	if err != nil {
		return false, fmt.Errorf("failed to delete template assets: %w", err)
	}

	// Delete template
	_, err = r.DB.Collection("templates").DeleteOne(ctx, bson.M{"_id": templateOID})
	if err != nil {
		return false, fmt.Errorf("failed to delete template: %w", err)
	}

	return true, nil
}

// ============================================================================
// FIELD RESOLVERS
// ============================================================================

// Files is the resolver for the files field.
func (r *templateResolver) Files(ctx context.Context, obj *model.Template) ([]*model.TemplateFile, error) {
	templateOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid template ID: %w", err)
	}

	cursor, err := r.DB.Collection("template_files").Find(ctx, bson.M{"templateId": templateOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var templateFileDocs []TemplateFileDoc
	if err = cursor.All(ctx, &templateFileDocs); err != nil {
		return nil, err
	}

	files := make([]*model.TemplateFile, len(templateFileDocs))
	for i, tf := range templateFileDocs {
		files[i] = &model.TemplateFile{
			ID:         tf.ID.Hex(),
			TemplateID: tf.TemplateID.Hex(),
			Name:       tf.Name,
			Type:       stringToFileType(tf.Type),
			Content:    tf.Content,
		}
	}

	return files, nil
}

// Assets is the resolver for the assets field.
func (r *templateResolver) Assets(ctx context.Context, obj *model.Template) ([]*model.TemplateAsset, error) {
	templateOID, err := toObjectID(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid template ID: %w", err)
	}

	cursor, err := r.DB.Collection("template_assets").Find(ctx, bson.M{"templateId": templateOID})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var templateAssetDocs []TemplateAssetDoc
	if err = cursor.All(ctx, &templateAssetDocs); err != nil {
		return nil, err
	}

	assets := make([]*model.TemplateAsset, len(templateAssetDocs))
	for i, ta := range templateAssetDocs {
		assets[i] = &model.TemplateAsset{
			ID:         ta.ID.Hex(),
			TemplateID: ta.TemplateID.Hex(),
			Path:       ta.Path,
			MimeType:   ta.MimeType,
			Size:       int32(ta.Size),
			CreatedAt:  ta.CreatedAt.Format(time.RFC3339),
		}
	}

	return assets, nil
}

